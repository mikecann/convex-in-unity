// <auto-generated>
//     This file was generated by uniffi-bindgen-cs v0.9.0+v0.28.3
//     See https://github.com/NordSecurity/uniffi-bindgen-cs for more information.
// </auto-generated>

#nullable enable




using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Threading.Tasks;
namespace uniffi.convexmobile
{



    // This is a helper for safely working with byte buffers returned from the Rust code.
    // A rust-owned buffer is represented by its capacity, its current length, and a
    // pointer to the underlying data.

    [StructLayout(LayoutKind.Sequential)]
    internal struct RustBuffer
    {
        public ulong capacity;
        public ulong len;
        public IntPtr data;

        public static RustBuffer Alloc(int size)
        {
            return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                var buffer = _UniFFILib.ffi_convexmobile_rustbuffer_alloc(Convert.ToUInt64(size), ref status);
                if (buffer.data == IntPtr.Zero)
                {
                    throw new AllocationException($"RustBuffer.Alloc() returned null data pointer (size={size})");
                }
                return buffer;
            });
        }

        public static void Free(RustBuffer buffer)
        {
            _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_convexmobile_rustbuffer_free(buffer, ref status);
            });
        }

        public static BigEndianStream MemoryStream(IntPtr data, long length)
        {
            unsafe
            {
                return new BigEndianStream(new UnmanagedMemoryStream((byte*)data.ToPointer(), length));
            }
        }

        public BigEndianStream AsStream()
        {
            unsafe
            {
                return new BigEndianStream(
                    new UnmanagedMemoryStream((byte*)data.ToPointer(), Convert.ToInt64(len))
                );
            }
        }

        public BigEndianStream AsWriteableStream()
        {
            unsafe
            {
                return new BigEndianStream(
                    new UnmanagedMemoryStream(
                        (byte*)data.ToPointer(),
                        Convert.ToInt64(capacity),
                        Convert.ToInt64(capacity),
                        FileAccess.Write
                    )
                );
            }
        }
    }

    // This is a helper for safely passing byte references into the rust code.
    // It's not actually used at the moment, because there aren't many things that you
    // can take a direct pointer to managed memory, and if we're going to copy something
    // then we might as well copy it into a `RustBuffer`. But it's here for API
    // completeness.

    [StructLayout(LayoutKind.Sequential)]
    internal struct ForeignBytes
    {
        public int length;
        public IntPtr data;
    }


    // The FfiConverter interface handles converter types to and from the FFI
    //
    // All implementing objects should be public to support external types.  When a
    // type is external we need to import it's FfiConverter.
    internal abstract class FfiConverter<CsType, FfiType>
    {
        // Convert an FFI type to a C# type
        public abstract CsType Lift(FfiType value);

        // Convert C# type to an FFI type
        public abstract FfiType Lower(CsType value);

        // Read a C# type from a `ByteBuffer`
        public abstract CsType Read(BigEndianStream stream);

        // Calculate bytes to allocate when creating a `RustBuffer`
        //
        // This must return at least as many bytes as the write() function will
        // write. It can return more bytes than needed, for example when writing
        // Strings we can't know the exact bytes needed until we the UTF-8
        // encoding, so we pessimistically allocate the largest size possible (3
        // bytes per codepoint).  Allocating extra bytes is not really a big deal
        // because the `RustBuffer` is short-lived.
        public abstract int AllocationSize(CsType value);

        // Write a C# type to a `ByteBuffer`
        public abstract void Write(CsType value, BigEndianStream stream);

        // Lower a value into a `RustBuffer`
        //
        // This method lowers a value into a `RustBuffer` rather than the normal
        // FfiType.  It's used by the callback interface code.  Callback interface
        // returns are always serialized into a `RustBuffer` regardless of their
        // normal FFI type.
        public RustBuffer LowerIntoRustBuffer(CsType value)
        {
            var rbuf = RustBuffer.Alloc(AllocationSize(value));
            try
            {
                var stream = rbuf.AsWriteableStream();
                Write(value, stream);
                rbuf.len = Convert.ToUInt64(stream.Position);
                return rbuf;
            }
            catch
            {
                RustBuffer.Free(rbuf);
                throw;
            }
        }

        // Lift a value from a `RustBuffer`.
        //
        // This here mostly because of the symmetry with `lowerIntoRustBuffer()`.
        // It's currently only used by the `FfiConverterRustBuffer` class below.
        protected CsType LiftFromRustBuffer(RustBuffer rbuf)
        {
            var stream = rbuf.AsStream();
            try
            {
                var item = Read(stream);
                if (stream.HasRemaining())
                {
                    throw new InternalException("junk remaining in buffer after lifting, something is very wrong!!");
                }
                return item;
            }
            finally
            {
                RustBuffer.Free(rbuf);
            }
        }
    }

    // FfiConverter that uses `RustBuffer` as the FfiType
    internal abstract class FfiConverterRustBuffer<CsType> : FfiConverter<CsType, RustBuffer>
    {
        public override CsType Lift(RustBuffer value)
        {
            return LiftFromRustBuffer(value);
        }
        public override RustBuffer Lower(CsType value)
        {
            return LowerIntoRustBuffer(value);
        }
    }


    // A handful of classes and functions to support the generated data structures.
    // This would be a good candidate for isolating in its own ffi-support lib.
    // Error runtime.
    [StructLayout(LayoutKind.Sequential)]
    struct UniffiRustCallStatus
    {
        public sbyte code;
        public RustBuffer error_buf;

        public bool IsSuccess()
        {
            return code == 0;
        }

        public bool IsError()
        {
            return code == 1;
        }

        public bool IsPanic()
        {
            return code == 2;
        }
    }

    // Base class for all uniffi exceptions
    internal class UniffiException : System.Exception
    {
        public UniffiException() : base() { }
        public UniffiException(string message) : base(message) { }
    }

    internal class UndeclaredErrorException : UniffiException
    {
        public UndeclaredErrorException(string message) : base(message) { }
    }

    internal class PanicException : UniffiException
    {
        public PanicException(string message) : base(message) { }
    }

    internal class AllocationException : UniffiException
    {
        public AllocationException(string message) : base(message) { }
    }

    internal class InternalException : UniffiException
    {
        public InternalException(string message) : base(message) { }
    }

    internal class InvalidEnumException : InternalException
    {
        public InvalidEnumException(string message) : base(message)
        {
        }
    }

    internal class UniffiContractVersionException : UniffiException
    {
        public UniffiContractVersionException(string message) : base(message)
        {
        }
    }

    internal class UniffiContractChecksumException : UniffiException
    {
        public UniffiContractChecksumException(string message) : base(message)
        {
        }
    }

    // Each top-level error class has a companion object that can lift the error from the call status's rust buffer
    interface CallStatusErrorHandler<E> where E : System.Exception
    {
        E Lift(RustBuffer error_buf);
    }

    // CallStatusErrorHandler implementation for times when we don't expect a CALL_ERROR
    class NullCallStatusErrorHandler : CallStatusErrorHandler<UniffiException>
    {
        public static NullCallStatusErrorHandler INSTANCE = new NullCallStatusErrorHandler();

        public UniffiException Lift(RustBuffer error_buf)
        {
            RustBuffer.Free(error_buf);
            return new UndeclaredErrorException("library has returned an error not declared in UNIFFI interface file");
        }
    }

    // Helpers for calling Rust
    // In practice we usually need to be synchronized to call this safely, so it doesn't
    // synchronize itself
    class _UniffiHelpers
    {
        public delegate void RustCallAction(ref UniffiRustCallStatus status);
        public delegate U RustCallFunc<out U>(ref UniffiRustCallStatus status);

        // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
        public static U RustCallWithError<U, E>(CallStatusErrorHandler<E> errorHandler, RustCallFunc<U> callback)
            where E : UniffiException
        {
            var status = new UniffiRustCallStatus();
            var return_value = callback(ref status);
            if (status.IsSuccess())
            {
                return return_value;
            }
            else if (status.IsError())
            {
                throw errorHandler.Lift(status.error_buf);
            }
            else if (status.IsPanic())
            {
                // when the rust code sees a panic, it tries to construct a rustbuffer
                // with the message.  but if that code panics, then it just sends back
                // an empty buffer.
                if (status.error_buf.len > 0)
                {
                    throw new PanicException(FfiConverterString.INSTANCE.Lift(status.error_buf));
                }
                else
                {
                    throw new PanicException("Rust panic");
                }
            }
            else
            {
                throw new InternalException($"Unknown rust call status: {status.code}");
            }
        }

        // Call a rust function that returns a Result<>.  Pass in the Error class companion that corresponds to the Err
        public static void RustCallWithError<E>(CallStatusErrorHandler<E> errorHandler, RustCallAction callback)
            where E : UniffiException
        {
            _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            });
        }

        // Call a rust function that returns a plain value
        public static U RustCall<U>(RustCallFunc<U> callback)
        {
            return _UniffiHelpers.RustCallWithError(NullCallStatusErrorHandler.INSTANCE, callback);
        }

        // Call a rust function that returns a plain value
        public static void RustCall(RustCallAction callback)
        {
            _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                callback(ref status);
                return 0;
            });
        }
    }

    static class FFIObjectUtil
    {
        public static void DisposeAll(params Object?[] list)
        {
            foreach (var obj in list)
            {
                Dispose(obj);
            }
        }

        // Dispose is implemented by recursive type inspection at runtime. This is because
        // generating correct Dispose calls for recursive complex types, e.g. List<List<int>>
        // is quite cumbersome.
        private static void Dispose(dynamic? obj)
        {
            if (obj == null)
            {
                return;
            }

            if (obj is IDisposable disposable)
            {
                disposable.Dispose();
                return;
            }

            var type = obj.GetType();
            if (type != null)
            {
                if (type.IsGenericType)
                {
                    if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(List<>)))
                    {
                        foreach (var value in obj)
                        {
                            Dispose(value);
                        }
                    }
                    else if (type.GetGenericTypeDefinition().IsAssignableFrom(typeof(Dictionary<,>)))
                    {
                        foreach (var value in obj.Values)
                        {
                            Dispose(value);
                        }
                    }
                }
            }
        }
    }


    // Big endian streams are not yet available in dotnet :'(
    // https://github.com/dotnet/runtime/issues/26904

    class StreamUnderflowException : System.Exception
    {
        public StreamUnderflowException()
        {
        }
    }

    class BigEndianStream
    {
        Stream stream;
        public BigEndianStream(Stream stream)
        {
            this.stream = stream;
        }

        public bool HasRemaining()
        {
            return (stream.Length - stream.Position) > 0;
        }

        public long Position
        {
            get => stream.Position;
            set => stream.Position = value;
        }

        public void WriteBytes(byte[] value)
        {
            stream.Write(value, 0, value.Length);
        }

        public void WriteByte(byte value)
        {
            stream.WriteByte(value);
        }

        public void WriteUShort(ushort value)
        {
            stream.WriteByte((byte)(value >> 8));
            stream.WriteByte((byte)value);
        }

        public void WriteUInt(uint value)
        {
            stream.WriteByte((byte)(value >> 24));
            stream.WriteByte((byte)(value >> 16));
            stream.WriteByte((byte)(value >> 8));
            stream.WriteByte((byte)value);
        }

        public void WriteULong(ulong value)
        {
            WriteUInt((uint)(value >> 32));
            WriteUInt((uint)value);
        }

        public void WriteSByte(sbyte value)
        {
            stream.WriteByte((byte)value);
        }

        public void WriteShort(short value)
        {
            WriteUShort((ushort)value);
        }

        public void WriteInt(int value)
        {
            WriteUInt((uint)value);
        }

        public void WriteFloat(float value)
        {
            unsafe
            {
                WriteInt(*((int*)&value));
            }
        }

        public void WriteLong(long value)
        {
            WriteULong((ulong)value);
        }

        public void WriteDouble(double value)
        {
            WriteLong(BitConverter.DoubleToInt64Bits(value));
        }

        public byte[] ReadBytes(int length)
        {
            CheckRemaining(length);
            byte[] result = new byte[length];
            stream.Read(result, 0, length);
            return result;
        }

        public byte ReadByte()
        {
            CheckRemaining(1);
            return Convert.ToByte(stream.ReadByte());
        }

        public ushort ReadUShort()
        {
            CheckRemaining(2);
            return (ushort)(stream.ReadByte() << 8 | stream.ReadByte());
        }

        public uint ReadUInt()
        {
            CheckRemaining(4);
            return (uint)(stream.ReadByte() << 24
                | stream.ReadByte() << 16
                | stream.ReadByte() << 8
                | stream.ReadByte());
        }

        public ulong ReadULong()
        {
            return (ulong)ReadUInt() << 32 | (ulong)ReadUInt();
        }

        public sbyte ReadSByte()
        {
            return (sbyte)ReadByte();
        }

        public short ReadShort()
        {
            return (short)ReadUShort();
        }

        public int ReadInt()
        {
            return (int)ReadUInt();
        }

        public float ReadFloat()
        {
            unsafe
            {
                int value = ReadInt();
                return *((float*)&value);
            }
        }

        public long ReadLong()
        {
            return (long)ReadULong();
        }

        public double ReadDouble()
        {
            return BitConverter.Int64BitsToDouble(ReadLong());
        }

        private void CheckRemaining(int length)
        {
            if (stream.Length - stream.Position < length)
            {
                throw new StreamUnderflowException();
            }
        }
    }

    // Contains loading, initialization code,
    // and the FFI Function declarations in a com.sun.jna.Library.


    // This is an implementation detail that will be called internally by the public API.
    static class _UniFFILib
    {
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiRustFutureContinuationCallback(
            ulong @data, sbyte @pollResult
        );
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureFree(
            ulong @handle
        );
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiCallbackInterfaceFree(
            ulong @handle
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFuture
        {
            public ulong @handle;
            public IntPtr @free;
        }
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructU8
        {
            public byte @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteU8(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU8 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructI8
        {
            public sbyte @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteI8(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI8 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructU16
        {
            public ushort @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteU16(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU16 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructI16
        {
            public short @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteI16(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI16 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructU32
        {
            public uint @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteU32(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU32 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructI32
        {
            public int @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteI32(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI32 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructU64
        {
            public ulong @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteU64(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructU64 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructI64
        {
            public long @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteI64(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructI64 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructF32
        {
            public float @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteF32(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructF32 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructF64
        {
            public double @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteF64(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructF64 @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructPointer
        {
            public IntPtr @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompletePointer(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructPointer @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructRustBuffer
        {
            public RustBuffer @returnValue;
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteRustBuffer(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructRustBuffer @result
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiForeignFutureStructVoid
        {
            public UniffiRustCallStatus @callStatus;
        }
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiForeignFutureCompleteVoid(
            ulong @callbackData, _UniFFILib.UniffiForeignFutureStructVoid @result
        );
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiCallbackInterfaceQuerySubscriberMethod0(
            ulong @uniffiHandle, RustBuffer @message, RustBuffer @value, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err
        );
        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
        public delegate void UniffiCallbackInterfaceQuerySubscriberMethod1(
            ulong @uniffiHandle, RustBuffer @value, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err
        );
        [StructLayout(LayoutKind.Sequential)]
        public struct UniffiVTableCallbackInterfaceQuerySubscriber
        {
            public IntPtr @onError;
            public IntPtr @onUpdate;
            public IntPtr @uniffiFree;
        }



















































































        static _UniFFILib()
        {
            _UniFFILib.uniffiCheckContractApiVersion();
            _UniFFILib.uniffiCheckApiChecksums();

            UniffiCallbackInterfaceQuerySubscriber.Register();
        }

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_clone_mobileconvexclient(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_free_mobileconvexclient(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_constructor_mobileconvexclient_new(RustBuffer @deploymentUrl, RustBuffer @clientId, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_method_mobileconvexclient_action(IntPtr @ptr, RustBuffer @name, RustBuffer @args
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_method_mobileconvexclient_mutation(IntPtr @ptr, RustBuffer @name, RustBuffer @args
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_method_mobileconvexclient_query(IntPtr @ptr, RustBuffer @name, RustBuffer @args
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_method_mobileconvexclient_set_auth(IntPtr @ptr, RustBuffer @token
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_method_mobileconvexclient_subscribe(IntPtr @ptr, RustBuffer @name, RustBuffer @args, IntPtr @subscriber
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_clone_querysubscriber(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_free_querysubscriber(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_init_callback_vtable_querysubscriber(ref _UniFFILib.UniffiVTableCallbackInterfaceQuerySubscriber @vtable
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_method_querysubscriber_on_error(IntPtr @ptr, RustBuffer @message, RustBuffer @value, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_method_querysubscriber_on_update(IntPtr @ptr, RustBuffer @value, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr uniffi_convexmobile_fn_clone_subscriptionhandle(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_free_subscriptionhandle(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void uniffi_convexmobile_fn_method_subscriptionhandle_cancel(IntPtr @ptr, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern RustBuffer ffi_convexmobile_rustbuffer_alloc(ulong @size, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern RustBuffer ffi_convexmobile_rustbuffer_from_bytes(ForeignBytes @bytes, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rustbuffer_free(RustBuffer @buf, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern RustBuffer ffi_convexmobile_rustbuffer_reserve(RustBuffer @buf, ulong @additional, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_u8(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_u8(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_u8(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern byte ffi_convexmobile_rust_future_complete_u8(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_i8(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_i8(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_i8(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern sbyte ffi_convexmobile_rust_future_complete_i8(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_u16(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_u16(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_u16(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort ffi_convexmobile_rust_future_complete_u16(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_i16(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_i16(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_i16(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern short ffi_convexmobile_rust_future_complete_i16(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_u32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_u32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_u32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern uint ffi_convexmobile_rust_future_complete_u32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_i32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_i32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_i32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern int ffi_convexmobile_rust_future_complete_i32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_u64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_u64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_u64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ulong ffi_convexmobile_rust_future_complete_u64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_i64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_i64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_i64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern long ffi_convexmobile_rust_future_complete_i64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_f32(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_f32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_f32(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern float ffi_convexmobile_rust_future_complete_f32(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_f64(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_f64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_f64(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern double ffi_convexmobile_rust_future_complete_f64(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_pointer(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_pointer(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_pointer(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern IntPtr ffi_convexmobile_rust_future_complete_pointer(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_rust_buffer(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_rust_buffer(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_rust_buffer(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern RustBuffer ffi_convexmobile_rust_future_complete_rust_buffer(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_poll_void(IntPtr @handle, IntPtr @callback, IntPtr @callbackData
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_cancel_void(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_free_void(IntPtr @handle
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern void ffi_convexmobile_rust_future_complete_void(IntPtr @handle, ref UniffiRustCallStatus _uniffi_out_err
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_mobileconvexclient_action(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_mobileconvexclient_mutation(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_mobileconvexclient_query(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_mobileconvexclient_set_auth(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_mobileconvexclient_subscribe(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_querysubscriber_on_error(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_querysubscriber_on_update(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_method_subscriptionhandle_cancel(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern ushort uniffi_convexmobile_checksum_constructor_mobileconvexclient_new(
        );

        [DllImport("uniffi_convexmobile", CallingConvention = CallingConvention.Cdecl)]
        public static extern uint ffi_convexmobile_uniffi_contract_version(
        );



        static void uniffiCheckContractApiVersion()
        {
            var scaffolding_contract_version = _UniFFILib.ffi_convexmobile_uniffi_contract_version();
            if (26 != scaffolding_contract_version)
            {
                throw new UniffiContractVersionException($"uniffi.convexmobile: uniffi bindings expected version `26`, library returned `{scaffolding_contract_version}`");
            }
        }

        static void uniffiCheckApiChecksums()
        {
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_mobileconvexclient_action();
                if (checksum != 2118)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_mobileconvexclient_action` checksum `2118`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_mobileconvexclient_mutation();
                if (checksum != 29570)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_mobileconvexclient_mutation` checksum `29570`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_mobileconvexclient_query();
                if (checksum != 27750)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_mobileconvexclient_query` checksum `27750`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_mobileconvexclient_set_auth();
                if (checksum != 54530)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_mobileconvexclient_set_auth` checksum `54530`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_mobileconvexclient_subscribe();
                if (checksum != 60726)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_mobileconvexclient_subscribe` checksum `60726`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_querysubscriber_on_error();
                if (checksum != 20316)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_querysubscriber_on_error` checksum `20316`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_querysubscriber_on_update();
                if (checksum != 13905)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_querysubscriber_on_update` checksum `13905`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_method_subscriptionhandle_cancel();
                if (checksum != 26127)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_method_subscriptionhandle_cancel` checksum `26127`, library returned `{checksum}`");
                }
            }
            {
                var checksum = _UniFFILib.uniffi_convexmobile_checksum_constructor_mobileconvexclient_new();
                if (checksum != 52554)
                {
                    throw new UniffiContractChecksumException($"uniffi.convexmobile: uniffi bindings expected function `uniffi_convexmobile_checksum_constructor_mobileconvexclient_new` checksum `52554`, library returned `{checksum}`");
                }
            }
        }
    }

    // Public interface members begin here.

#pragma warning disable 8625




    class FfiConverterString : FfiConverter<string, RustBuffer>
    {
        public static FfiConverterString INSTANCE = new FfiConverterString();

        // Note: we don't inherit from FfiConverterRustBuffer, because we use a
        // special encoding when lowering/lifting.  We can use `RustBuffer.len` to
        // store our length and avoid writing it out to the buffer.
        public override string Lift(RustBuffer value)
        {
            try
            {
                var bytes = value.AsStream().ReadBytes(Convert.ToInt32(value.len));
                return System.Text.Encoding.UTF8.GetString(bytes);
            }
            finally
            {
                RustBuffer.Free(value);
            }
        }

        public override string Read(BigEndianStream stream)
        {
            var length = stream.ReadInt();
            var bytes = stream.ReadBytes(length);
            return System.Text.Encoding.UTF8.GetString(bytes);
        }

        public override RustBuffer Lower(string value)
        {
            var bytes = System.Text.Encoding.UTF8.GetBytes(value);
            var rbuf = RustBuffer.Alloc(bytes.Length);
            rbuf.AsWriteableStream().WriteBytes(bytes);
            return rbuf;
        }

        // TODO(CS)
        // We aren't sure exactly how many bytes our string will be once it's UTF-8
        // encoded.  Allocate 3 bytes per unicode codepoint which will always be
        // enough.
        public override int AllocationSize(string value)
        {
            const int sizeForLength = 4;
            var sizeForString = System.Text.Encoding.UTF8.GetByteCount(value);
            return sizeForLength + sizeForString;
        }

        public override void Write(string value, BigEndianStream stream)
        {
            var bytes = System.Text.Encoding.UTF8.GetBytes(value);
            stream.WriteInt(bytes.Length);
            stream.WriteBytes(bytes);
        }
    }



    internal interface IMobileConvexClient
    {
        /// <exception cref="ClientException"></exception>
        Task<string> Action(string @name, Dictionary<string, string> @args);
        /// <exception cref="ClientException"></exception>
        Task<string> Mutation(string @name, Dictionary<string, string> @args);
        /// <exception cref="ClientException"></exception>
        Task<string> Query(string @name, Dictionary<string, string> @args);
        /// <exception cref="ClientException"></exception>
        Task SetAuth(string? @token);
        /// <exception cref="ClientException"></exception>
        Task<SubscriptionHandle> Subscribe(string @name, Dictionary<string, string> @args, QuerySubscriber @subscriber);
    }
    internal class MobileConvexClient : IMobileConvexClient, IDisposable
    {
        protected IntPtr pointer;
        private int _wasDestroyed = 0;
        private long _callCounter = 1;

        public MobileConvexClient(IntPtr pointer)
        {
            this.pointer = pointer;
        }

        ~MobileConvexClient()
        {
            Destroy();
        }
        public MobileConvexClient(string @deploymentUrl, string @clientId) :
            this(
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus _status) =>
        _UniFFILib.uniffi_convexmobile_fn_constructor_mobileconvexclient_new(FfiConverterString.INSTANCE.Lower(@deploymentUrl), FfiConverterString.INSTANCE.Lower(@clientId), ref _status)
    ))
        { }

        protected void FreeRustArcPtr()
        {
            _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_convexmobile_fn_free_mobileconvexclient(this.pointer, ref status);
            });
        }

        protected IntPtr CloneRustArcPtr()
        {
            return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_convexmobile_fn_clone_mobileconvexclient(this.pointer, ref status);
            });
        }

        public void Destroy()
        {
            // Only allow a single call to this method.
            if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
            {
                // This decrement always matches the initial count of 1 given at creation time.
                if (Interlocked.Decrement(ref _callCounter) == 0)
                {
                    FreeRustArcPtr();
                }
            }
        }

        public void Dispose()
        {
            Destroy();
            GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
        }

        private void IncrementCallCounter()
        {
            // Check and increment the call counter, to keep the object alive.
            // This needs a compare-and-set retry loop in case of concurrent updates.
            long count;
            do
            {
                count = Interlocked.Read(ref _callCounter);
                if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
                if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

            } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
        }

        private void DecrementCallCounter()
        {
            // This decrement always matches the increment we performed above.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }

        internal void CallWithPointer(Action<IntPtr> action)
        {
            IncrementCallCounter();
            try
            {
                action(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }

        internal T CallWithPointer<T>(Func<IntPtr, T> func)
        {
            IncrementCallCounter();
            try
            {
                return func(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }


        /// <exception cref="ClientException"></exception>
        public async Task<string> Action(string @name, Dictionary<string, string> @args)
        {
            return await _UniFFIAsync.UniffiRustCallAsync(
                // Get rust future
                CallWithPointer(thisPtr =>
                {
                    return _UniFFILib.uniffi_convexmobile_fn_method_mobileconvexclient_action(thisPtr, FfiConverterString.INSTANCE.Lower(@name), FfiConverterDictionaryStringString.INSTANCE.Lower(@args));
                }),
                // Poll
                (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_convexmobile_rust_future_poll_rust_buffer(future, continuation, data),
                // Complete
                (IntPtr future, ref UniffiRustCallStatus status) =>
                {
                    return _UniFFILib.ffi_convexmobile_rust_future_complete_rust_buffer(future, ref status);
                },
                // Free
                (IntPtr future) => _UniFFILib.ffi_convexmobile_rust_future_free_rust_buffer(future),
                // Lift
                (result) => FfiConverterString.INSTANCE.Lift(result),
                // Error
                FfiConverterTypeClientError.INSTANCE
            );
        }

        /// <exception cref="ClientException"></exception>
        public async Task<string> Mutation(string @name, Dictionary<string, string> @args)
        {
            return await _UniFFIAsync.UniffiRustCallAsync(
                // Get rust future
                CallWithPointer(thisPtr =>
                {
                    return _UniFFILib.uniffi_convexmobile_fn_method_mobileconvexclient_mutation(thisPtr, FfiConverterString.INSTANCE.Lower(@name), FfiConverterDictionaryStringString.INSTANCE.Lower(@args));
                }),
                // Poll
                (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_convexmobile_rust_future_poll_rust_buffer(future, continuation, data),
                // Complete
                (IntPtr future, ref UniffiRustCallStatus status) =>
                {
                    return _UniFFILib.ffi_convexmobile_rust_future_complete_rust_buffer(future, ref status);
                },
                // Free
                (IntPtr future) => _UniFFILib.ffi_convexmobile_rust_future_free_rust_buffer(future),
                // Lift
                (result) => FfiConverterString.INSTANCE.Lift(result),
                // Error
                FfiConverterTypeClientError.INSTANCE
            );
        }

        /// <exception cref="ClientException"></exception>
        public async Task<string> Query(string @name, Dictionary<string, string> @args)
        {
            return await _UniFFIAsync.UniffiRustCallAsync(
                // Get rust future
                CallWithPointer(thisPtr =>
                {
                    return _UniFFILib.uniffi_convexmobile_fn_method_mobileconvexclient_query(thisPtr, FfiConverterString.INSTANCE.Lower(@name), FfiConverterDictionaryStringString.INSTANCE.Lower(@args));
                }),
                // Poll
                (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_convexmobile_rust_future_poll_rust_buffer(future, continuation, data),
                // Complete
                (IntPtr future, ref UniffiRustCallStatus status) =>
                {
                    return _UniFFILib.ffi_convexmobile_rust_future_complete_rust_buffer(future, ref status);
                },
                // Free
                (IntPtr future) => _UniFFILib.ffi_convexmobile_rust_future_free_rust_buffer(future),
                // Lift
                (result) => FfiConverterString.INSTANCE.Lift(result),
                // Error
                FfiConverterTypeClientError.INSTANCE
            );
        }

        /// <exception cref="ClientException"></exception>
        public async Task SetAuth(string? @token)
        {
            await _UniFFIAsync.UniffiRustCallAsync(
            // Get rust future
            CallWithPointer(thisPtr =>
            {
                return _UniFFILib.uniffi_convexmobile_fn_method_mobileconvexclient_set_auth(thisPtr, FfiConverterOptionalString.INSTANCE.Lower(@token));
            }),
            // Poll
            (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_convexmobile_rust_future_poll_void(future, continuation, data),
            // Complete
            (IntPtr future, ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.ffi_convexmobile_rust_future_complete_void(future, ref status);
            },
            // Free
            (IntPtr future) => _UniFFILib.ffi_convexmobile_rust_future_free_void(future),
            // Error
            FfiConverterTypeClientError.INSTANCE
        );
        }

        /// <exception cref="ClientException"></exception>
        public async Task<SubscriptionHandle> Subscribe(string @name, Dictionary<string, string> @args, QuerySubscriber @subscriber)
        {
            return await _UniFFIAsync.UniffiRustCallAsync(
                // Get rust future
                CallWithPointer(thisPtr =>
                {
                    return _UniFFILib.uniffi_convexmobile_fn_method_mobileconvexclient_subscribe(thisPtr, FfiConverterString.INSTANCE.Lower(@name), FfiConverterDictionaryStringString.INSTANCE.Lower(@args), FfiConverterTypeQuerySubscriber.INSTANCE.Lower(@subscriber));
                }),
                // Poll
                (IntPtr future, IntPtr continuation, IntPtr data) => _UniFFILib.ffi_convexmobile_rust_future_poll_pointer(future, continuation, data),
                // Complete
                (IntPtr future, ref UniffiRustCallStatus status) =>
                {
                    return _UniFFILib.ffi_convexmobile_rust_future_complete_pointer(future, ref status);
                },
                // Free
                (IntPtr future) => _UniFFILib.ffi_convexmobile_rust_future_free_pointer(future),
                // Lift
                (result) => FfiConverterTypeSubscriptionHandle.INSTANCE.Lift(result),
                // Error
                FfiConverterTypeClientError.INSTANCE
            );
        }



    }
    class FfiConverterTypeMobileConvexClient : FfiConverter<MobileConvexClient, IntPtr>
    {
        public static FfiConverterTypeMobileConvexClient INSTANCE = new FfiConverterTypeMobileConvexClient();


        public override IntPtr Lower(MobileConvexClient value)
        {
            return value.CallWithPointer(thisPtr => thisPtr);
        }

        public override MobileConvexClient Lift(IntPtr value)
        {
            return new MobileConvexClient(value);
        }

        public override MobileConvexClient Read(BigEndianStream stream)
        {
            return Lift(new IntPtr(stream.ReadLong()));
        }

        public override int AllocationSize(MobileConvexClient value)
        {
            return 8;
        }

        public override void Write(MobileConvexClient value, BigEndianStream stream)
        {
            stream.WriteLong(Lower(value).ToInt64());
        }
    }



    internal interface QuerySubscriber
    {
        void OnError(string @message, string? @value);
        void OnUpdate(string @value);
    }
    internal class QuerySubscriberImpl : QuerySubscriber, IDisposable
    {
        protected IntPtr pointer;
        private int _wasDestroyed = 0;
        private long _callCounter = 1;

        public QuerySubscriberImpl(IntPtr pointer)
        {
            this.pointer = pointer;
        }

        ~QuerySubscriberImpl()
        {
            Destroy();
        }

        protected void FreeRustArcPtr()
        {
            _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_convexmobile_fn_free_querysubscriber(this.pointer, ref status);
            });
        }

        protected IntPtr CloneRustArcPtr()
        {
            return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_convexmobile_fn_clone_querysubscriber(this.pointer, ref status);
            });
        }

        public void Destroy()
        {
            // Only allow a single call to this method.
            if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
            {
                // This decrement always matches the initial count of 1 given at creation time.
                if (Interlocked.Decrement(ref _callCounter) == 0)
                {
                    FreeRustArcPtr();
                }
            }
        }

        public void Dispose()
        {
            Destroy();
            GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
        }

        private void IncrementCallCounter()
        {
            // Check and increment the call counter, to keep the object alive.
            // This needs a compare-and-set retry loop in case of concurrent updates.
            long count;
            do
            {
                count = Interlocked.Read(ref _callCounter);
                if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
                if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

            } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
        }

        private void DecrementCallCounter()
        {
            // This decrement always matches the increment we performed above.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }

        internal void CallWithPointer(Action<IntPtr> action)
        {
            IncrementCallCounter();
            try
            {
                action(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }

        internal T CallWithPointer<T>(Func<IntPtr, T> func)
        {
            IncrementCallCounter();
            try
            {
                return func(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }


        public void OnError(string @message, string? @value)
        {
            CallWithPointer(thisPtr =>
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus _status) =>
        _UniFFILib.uniffi_convexmobile_fn_method_querysubscriber_on_error(thisPtr, FfiConverterString.INSTANCE.Lower(@message), FfiConverterOptionalString.INSTANCE.Lower(@value), ref _status)
    ));
        }



        public void OnUpdate(string @value)
        {
            CallWithPointer(thisPtr =>
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus _status) =>
        _UniFFILib.uniffi_convexmobile_fn_method_querysubscriber_on_update(thisPtr, FfiConverterString.INSTANCE.Lower(@value), ref _status)
    ));
        }





    }
    class UniffiCallbackInterfaceQuerySubscriber
    {
        static void OnError(ulong @uniffiHandle, RustBuffer @message, RustBuffer @value, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
        {
            var handle = @uniffiHandle;
            if (FfiConverterTypeQuerySubscriber.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
            {
                uniffiObject.OnError(
                    FfiConverterString.INSTANCE.Lift(@message),
                    FfiConverterOptionalString.INSTANCE.Lift(@value));
            }
            else
            {
                throw new InternalException($"No callback in handlemap '{handle}'");
            }
        }
        static void OnUpdate(ulong @uniffiHandle, RustBuffer @value, IntPtr @uniffiOutReturn, ref UniffiRustCallStatus _uniffi_out_err)
        {
            var handle = @uniffiHandle;
            if (FfiConverterTypeQuerySubscriber.INSTANCE.handleMap.TryGet(handle, out var uniffiObject))
            {
                uniffiObject.OnUpdate(
                    FfiConverterString.INSTANCE.Lift(@value));
            }
            else
            {
                throw new InternalException($"No callback in handlemap '{handle}'");
            }
        }

        static void UniffiFree(ulong @handle)
        {
            FfiConverterTypeQuerySubscriber.INSTANCE.handleMap.Remove(@handle);
        }
        static _UniFFILib.UniffiCallbackInterfaceQuerySubscriberMethod0 _m0 = new _UniFFILib.UniffiCallbackInterfaceQuerySubscriberMethod0(OnError);
        static _UniFFILib.UniffiCallbackInterfaceQuerySubscriberMethod1 _m1 = new _UniFFILib.UniffiCallbackInterfaceQuerySubscriberMethod1(OnUpdate);
        static _UniFFILib.UniffiCallbackInterfaceFree _callback_interface_free = new _UniFFILib.UniffiCallbackInterfaceFree(UniffiFree);

        public static _UniFFILib.UniffiVTableCallbackInterfaceQuerySubscriber _vtable = new _UniFFILib.UniffiVTableCallbackInterfaceQuerySubscriber
        {
            @onError = Marshal.GetFunctionPointerForDelegate(_m0),
            @onUpdate = Marshal.GetFunctionPointerForDelegate(_m1),
            @uniffiFree = Marshal.GetFunctionPointerForDelegate(_callback_interface_free)
        };

        public static void Register()
        {
            _UniFFILib.uniffi_convexmobile_fn_init_callback_vtable_querysubscriber(ref UniffiCallbackInterfaceQuerySubscriber._vtable);
        }
    }

    class ConcurrentHandleMap<T> where T : notnull
    {
        Dictionary<ulong, T> map = new Dictionary<ulong, T>();

        Object lock_ = new Object();
        ulong currentHandle = 0;

        public ulong Insert(T obj)
        {
            lock (lock_)
            {
                currentHandle += 1;
                map[currentHandle] = obj;
                return currentHandle;
            }
        }

        public bool TryGet(ulong handle, out T result)
        {
            lock (lock_)
            {
#pragma warning disable 8601 // Possible null reference assignment
                return map.TryGetValue(handle, out result);
#pragma warning restore 8601
            }
        }

        public T Get(ulong handle)
        {
            if (TryGet(handle, out var result))
            {
                return result;
            }
            else
            {
                throw new InternalException("ConcurrentHandleMap: Invalid handle");
            }
        }

        public bool Remove(ulong handle)
        {
            return Remove(handle, out T result);
        }

        public bool Remove(ulong handle, out T result)
        {
            lock (lock_)
            {
                // Possible null reference assignment
#pragma warning disable 8601
                if (map.TryGetValue(handle, out result))
                {
#pragma warning restore 8601
                    map.Remove(handle);
                    return true;
                }
                else
                {
                    return false;
                }
            }
        }
    }
    static class UniffiCallbackResponseStatus
    {
        public static sbyte SUCCESS = 0;
        public static sbyte ERROR = 1;
        public static sbyte UNEXPECTED_ERROR = 2;
    }

    class FfiConverterTypeQuerySubscriber : FfiConverter<QuerySubscriber, IntPtr>
    {
        public ConcurrentHandleMap<QuerySubscriber> handleMap = new ConcurrentHandleMap<QuerySubscriber>();

        public static FfiConverterTypeQuerySubscriber INSTANCE = new FfiConverterTypeQuerySubscriber();


        public override IntPtr Lower(QuerySubscriber value)
        {
            return (IntPtr)handleMap.Insert(value);
        }

        public override QuerySubscriber Lift(IntPtr value)
        {
            return new QuerySubscriberImpl(value);
        }

        public override QuerySubscriber Read(BigEndianStream stream)
        {
            return Lift(new IntPtr(stream.ReadLong()));
        }

        public override int AllocationSize(QuerySubscriber value)
        {
            return 8;
        }

        public override void Write(QuerySubscriber value, BigEndianStream stream)
        {
            stream.WriteLong(Lower(value).ToInt64());
        }
    }



    internal interface ISubscriptionHandle
    {
        void Cancel();
    }
    internal class SubscriptionHandle : ISubscriptionHandle, IDisposable
    {
        protected IntPtr pointer;
        private int _wasDestroyed = 0;
        private long _callCounter = 1;

        public SubscriptionHandle(IntPtr pointer)
        {
            this.pointer = pointer;
        }

        ~SubscriptionHandle()
        {
            Destroy();
        }

        protected void FreeRustArcPtr()
        {
            _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                _UniFFILib.uniffi_convexmobile_fn_free_subscriptionhandle(this.pointer, ref status);
            });
        }

        protected IntPtr CloneRustArcPtr()
        {
            return _UniffiHelpers.RustCall((ref UniffiRustCallStatus status) =>
            {
                return _UniFFILib.uniffi_convexmobile_fn_clone_subscriptionhandle(this.pointer, ref status);
            });
        }

        public void Destroy()
        {
            // Only allow a single call to this method.
            if (Interlocked.CompareExchange(ref _wasDestroyed, 1, 0) == 0)
            {
                // This decrement always matches the initial count of 1 given at creation time.
                if (Interlocked.Decrement(ref _callCounter) == 0)
                {
                    FreeRustArcPtr();
                }
            }
        }

        public void Dispose()
        {
            Destroy();
            GC.SuppressFinalize(this); // Suppress finalization to avoid unnecessary GC overhead.
        }

        private void IncrementCallCounter()
        {
            // Check and increment the call counter, to keep the object alive.
            // This needs a compare-and-set retry loop in case of concurrent updates.
            long count;
            do
            {
                count = Interlocked.Read(ref _callCounter);
                if (count == 0L) throw new System.ObjectDisposedException(String.Format("'{0}' object has already been destroyed", this.GetType().Name));
                if (count == long.MaxValue) throw new System.OverflowException(String.Format("'{0}' call counter would overflow", this.GetType().Name));

            } while (Interlocked.CompareExchange(ref _callCounter, count + 1, count) != count);
        }

        private void DecrementCallCounter()
        {
            // This decrement always matches the increment we performed above.
            if (Interlocked.Decrement(ref _callCounter) == 0)
            {
                FreeRustArcPtr();
            }
        }

        internal void CallWithPointer(Action<IntPtr> action)
        {
            IncrementCallCounter();
            try
            {
                action(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }

        internal T CallWithPointer<T>(Func<IntPtr, T> func)
        {
            IncrementCallCounter();
            try
            {
                return func(CloneRustArcPtr());
            }
            finally
            {
                DecrementCallCounter();
            }
        }


        public void Cancel()
        {
            CallWithPointer(thisPtr =>
        _UniffiHelpers.RustCall((ref UniffiRustCallStatus _status) =>
        _UniFFILib.uniffi_convexmobile_fn_method_subscriptionhandle_cancel(thisPtr, ref _status)
    ));
        }





    }
    class FfiConverterTypeSubscriptionHandle : FfiConverter<SubscriptionHandle, IntPtr>
    {
        public static FfiConverterTypeSubscriptionHandle INSTANCE = new FfiConverterTypeSubscriptionHandle();


        public override IntPtr Lower(SubscriptionHandle value)
        {
            return value.CallWithPointer(thisPtr => thisPtr);
        }

        public override SubscriptionHandle Lift(IntPtr value)
        {
            return new SubscriptionHandle(value);
        }

        public override SubscriptionHandle Read(BigEndianStream stream)
        {
            return Lift(new IntPtr(stream.ReadLong()));
        }

        public override int AllocationSize(SubscriptionHandle value)
        {
            return 8;
        }

        public override void Write(SubscriptionHandle value, BigEndianStream stream)
        {
            stream.WriteLong(Lower(value).ToInt64());
        }
    }





    internal class ClientException : UniffiException
    {
        ClientException() : base() { }
        ClientException(String @Message) : base(@Message) { }

        // Each variant is a nested class


        public class InternalException : ClientException
        {
            // Members
            public string @msg;

            // Constructor
            public InternalException(
                    string @msg) : base(
                    "@msg" + "=" + @msg)
            {

                this.@msg = @msg;
            }
        }


        public class ConvexException : ClientException
        {
            // Members
            public string @data;

            // Constructor
            public ConvexException(
                    string @data) : base(
                    "@data" + "=" + @data)
            {

                this.@data = @data;
            }
        }


        public class ServerException : ClientException
        {
            // Members
            public string @msg;

            // Constructor
            public ServerException(
                    string @msg) : base(
                    "@msg" + "=" + @msg)
            {

                this.@msg = @msg;
            }
        }



    }

    class FfiConverterTypeClientError : FfiConverterRustBuffer<ClientException>, CallStatusErrorHandler<ClientException>
    {
        public static FfiConverterTypeClientError INSTANCE = new FfiConverterTypeClientError();

        public override ClientException Read(BigEndianStream stream)
        {
            var value = stream.ReadInt();
            switch (value)
            {
                case 1:
                    return new ClientException.InternalException(
                        FfiConverterString.INSTANCE.Read(stream));
                case 2:
                    return new ClientException.ConvexException(
                        FfiConverterString.INSTANCE.Read(stream));
                case 3:
                    return new ClientException.ServerException(
                        FfiConverterString.INSTANCE.Read(stream));
                default:
                    throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeClientError.Read()", value));
            }
        }

        public override int AllocationSize(ClientException value)
        {
            switch (value)
            {

                case ClientException.InternalException variant_value:
                    return 4
                        + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);

                case ClientException.ConvexException variant_value:
                    return 4
                        + FfiConverterString.INSTANCE.AllocationSize(variant_value.@data);

                case ClientException.ServerException variant_value:
                    return 4
                        + FfiConverterString.INSTANCE.AllocationSize(variant_value.@msg);
                default:
                    throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeClientError.AllocationSize()", value));
            }
        }

        public override void Write(ClientException value, BigEndianStream stream)
        {
            switch (value)
            {
                case ClientException.InternalException variant_value:
                    stream.WriteInt(1);
                    FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                    break;
                case ClientException.ConvexException variant_value:
                    stream.WriteInt(2);
                    FfiConverterString.INSTANCE.Write(variant_value.@data, stream);
                    break;
                case ClientException.ServerException variant_value:
                    stream.WriteInt(3);
                    FfiConverterString.INSTANCE.Write(variant_value.@msg, stream);
                    break;
                default:
                    throw new InternalException(String.Format("invalid error value '{0}' in FfiConverterTypeClientError.Write()", value));
            }
        }
    }




    class FfiConverterOptionalString : FfiConverterRustBuffer<string?>
    {
        public static FfiConverterOptionalString INSTANCE = new FfiConverterOptionalString();

        public override string? Read(BigEndianStream stream)
        {
            if (stream.ReadByte() == 0)
            {
                return null;
            }
            return FfiConverterString.INSTANCE.Read(stream);
        }

        public override int AllocationSize(string? value)
        {
            if (value == null)
            {
                return 1;
            }
            else
            {
                return 1 + FfiConverterString.INSTANCE.AllocationSize((string)value);
            }
        }

        public override void Write(string? value, BigEndianStream stream)
        {
            if (value == null)
            {
                stream.WriteByte(0);
            }
            else
            {
                stream.WriteByte(1);
                FfiConverterString.INSTANCE.Write((string)value, stream);
            }
        }
    }




    class FfiConverterDictionaryStringString : FfiConverterRustBuffer<Dictionary<string, string>>
    {
        public static FfiConverterDictionaryStringString INSTANCE = new FfiConverterDictionaryStringString();

        public override Dictionary<string, string> Read(BigEndianStream stream)
        {
            var result = new Dictionary<string, string>();
            var len = stream.ReadInt();
            for (int i = 0; i < len; i++)
            {
                var key = FfiConverterString.INSTANCE.Read(stream);
                var value = FfiConverterString.INSTANCE.Read(stream);
                result[key] = value;
            }
            return result;
        }

        public override int AllocationSize(Dictionary<string, string> value)
        {
            var sizeForLength = 4;

            // details/1-empty-list-as-default-method-parameter.md
            if (value == null)
            {
                return sizeForLength;
            }

            var sizeForItems = value.Select(item =>
            {
                return FfiConverterString.INSTANCE.AllocationSize(item.Key) +
                    FfiConverterString.INSTANCE.AllocationSize(item.Value);
            }).Sum();
            return sizeForLength + sizeForItems;
        }

        public override void Write(Dictionary<string, string> value, BigEndianStream stream)
        {
            // details/1-empty-list-as-default-method-parameter.md
            if (value == null)
            {
                stream.WriteInt(0);
                return;
            }

            stream.WriteInt(value.Count);
            foreach (var item in value)
            {
                FfiConverterString.INSTANCE.Write(item.Key, stream);
                FfiConverterString.INSTANCE.Write(item.Value, stream);
            }
        }
    }





    [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
    delegate void UniFfiFutureCallback(IntPtr continuationHandle, byte pollResult);

    internal static class _UniFFIAsync
    {
        internal const byte UNIFFI_RUST_FUTURE_POLL_READY = 0;
        // internal const byte UNIFFI_RUST_FUTURE_POLL_MAYBE_READY = 1;

        internal static ConcurrentHandleMap<TaskCompletionSource<byte>> _async_handle_map = new ConcurrentHandleMap<TaskCompletionSource<byte>>();
        public static ConcurrentHandleMap<CancellationTokenSource> _foreign_futures_map = new ConcurrentHandleMap<CancellationTokenSource>();

        // FFI type for Rust future continuations
        internal class UniffiRustFutureContinuationCallback
        {
            public static UniFfiFutureCallback callback = Callback;

            public static void Callback(IntPtr continuationHandle, byte pollResult)
            {
                if (_async_handle_map.Remove((ulong)continuationHandle.ToInt64(), out TaskCompletionSource<byte> task))
                {
                    task.SetResult(pollResult);
                }
                else
                {
                    throw new InternalException($"Unable to find continuation handle: {continuationHandle}");
                }
            }
        }

        public class UniffiForeignFutureFreeCallback
        {
            public static _UniFFILib.UniffiForeignFutureFree callback = Callback;

            public static void Callback(ulong handle)
            {
                if (_foreign_futures_map.Remove(handle, out CancellationTokenSource task))
                {
                    task.Cancel();
                }
                else
                {
                    throw new InternalException($"Unable to find cancellation token: {handle}");
                }
            }
        }

        public delegate F CompleteFuncDelegate<F>(IntPtr ptr, ref UniffiRustCallStatus status);

        public delegate void CompleteActionDelegate(IntPtr ptr, ref UniffiRustCallStatus status);

        private static async Task PollFuture(IntPtr rustFuture, Action<IntPtr, IntPtr, IntPtr> pollFunc)
        {
            byte pollResult;
            do
            {
                var tcs = new TaskCompletionSource<byte>(TaskCreationOptions.RunContinuationsAsynchronously);
                IntPtr callback = Marshal.GetFunctionPointerForDelegate(UniffiRustFutureContinuationCallback.callback);
                ulong mapEntry = _async_handle_map.Insert(tcs);
                pollFunc(rustFuture, callback, (IntPtr)mapEntry);
                pollResult = await tcs.Task;
            }
            while (pollResult != UNIFFI_RUST_FUTURE_POLL_READY);
        }

        public static async Task<T> UniffiRustCallAsync<T, F, E>(
            IntPtr rustFuture,
            Action<IntPtr, IntPtr, IntPtr> pollFunc,
            CompleteFuncDelegate<F> completeFunc,
            Action<IntPtr> freeFunc,
            Func<F, T> liftFunc,
            CallStatusErrorHandler<E> errorHandler
        ) where E : UniffiException
        {
            try
            {
                await PollFuture(rustFuture, pollFunc);
                var result = _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));
                return liftFunc(result);
            }
            finally
            {
                freeFunc(rustFuture);
            }
        }

        public static async Task UniffiRustCallAsync<E>(
            IntPtr rustFuture,
            Action<IntPtr, IntPtr, IntPtr> pollFunc,
            CompleteActionDelegate completeFunc,
            Action<IntPtr> freeFunc,
            CallStatusErrorHandler<E> errorHandler
        ) where E : UniffiException
        {
            try
            {
                await PollFuture(rustFuture, pollFunc);
                _UniffiHelpers.RustCallWithError(errorHandler, (ref UniffiRustCallStatus status) => completeFunc(rustFuture, ref status));

            }
            finally
            {
                freeFunc(rustFuture);
            }
        }
    }
#pragma warning restore 8625
    internal static class ConvexmobileMethods
    {
    }

};